# 系统架构设计

## 1. 概述

本系统旨在设计并实现一个高并发的NestJS订单后端demo，包含用户、订单和库存三个核心微服务。系统将利用消息队列（Kafka）实现服务间的异步通信，使用MySQL作为数据存储，并通过Redis缓存机制在高并发场景下避免超卖问题。同时，系统将提供JMeter性能测试脚本和自动化测试脚本，以验证系统的性能和功能。

## 2. 核心组件

- **用户微服务 (User Service)**: 负责用户的注册、登录、身份验证（JWT）。
- **订单微服务 (Order Service)**: 负责订单的创建、查询、更新等操作，与库存服务通过消息队列进行通信。
- **库存微服务 (Inventory Service)**: 负责商品的库存管理，接收订单服务的消息进行库存扣减，并处理库存回滚等逻辑。
- **消息队列 (Kafka)**: 用于微服务间的异步通信，解耦服务，提高系统吞吐量和可伸缩性。
- **数据库 (MySQL)**: 用于持久化存储用户、订单和库存数据。
- **缓存 (Redis)**: 用于在高并发场景下，对库存进行预扣减，防止超卖，并提高数据读取速度。
- **API 网关 (可选)**: 统一入口，负责请求路由、负载均衡、认证鉴权等（本次demo暂不实现，认证由用户服务处理）。

## 3. 技术栈

- **后端框架**: NestJS (TypeScript)
- **数据库**: MySQL
- **缓存**: Redis
- **消息队列**: Kafka
- **身份验证**: JWT (JSON Web Tokens)
- **测试工具**: JMeter (性能测试), Jest/Supertest (自动化测试)
- **容器化**: Docker, Docker Compose

## 4. 微服务间通信

- **同步通信**: 用户服务对外提供RESTful API，订单服务对外提供RESTful API。
- **异步通信**: 订单服务和库存服务之间通过Kafka进行消息传递，例如订单创建成功后发送库存扣减消息，库存扣减成功或失败后发送相应消息给订单服务。

## 5. 高并发与防超卖策略

- **Redis预扣减**: 用户下单时，先在Redis中对库存进行预扣减。如果Redis库存不足，则直接返回失败。此操作利用Redis的原子性。
- **消息队列异步处理**: 订单创建成功后，通过Kafka发送消息给库存服务进行实际库存扣减。这可以避免同步调用造成的性能瓶颈。
- **数据库乐观锁/悲观锁 (可选)**: 在实际库存扣减时，可以考虑在数据库层面使用乐观锁或悲观锁，确保数据一致性。本次demo主要依赖Redis预扣减和消息队列。

## 6. 部署方案

- 使用Docker Compose编排各个微服务、MySQL、Redis和Kafka，实现快速部署和本地开发环境搭建。

## 7. 测试策略

- **JMeter**: 模拟高并发用户请求，测试订单创建、库存扣减等核心业务流程的性能和稳定性，验证防超卖机制。
- **自动化测试**: 使用Jest/Supertest对各个微服务的API进行单元测试和集成测试，确保功能正确性。



